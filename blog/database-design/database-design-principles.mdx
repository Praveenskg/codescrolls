---
title: 'Database Design Principles Every Developer Should Know'
description:
  'Master database design with normalization, relationships, indexing, and
  performance optimization. Learn SQL/NoSQL patterns, data modeling, and best
  practices for scalable applications.'
slug: database-design-principles
authors: praveen
image: /img/blog/react.png
date: 2025-10-17
keywords:
  [
    'database design',
    'normalization',
    'sql',
    'nosql',
    'data modeling',
    'database schema',
    'relationships',
    'indexing',
    'performance optimization',
  ]
tags:
  [database, design, sql, nosql, normalization, indexing, performance, backend]
---

import CodeBlock from '@theme/CodeBlock';

# üóÑÔ∏è Database Design Principles Every Developer Should Know

Database design is the foundation of any data-driven application. Poor design
leads to performance issues, data inconsistencies, and maintenance nightmares.
Good design ensures scalability, maintainability, and optimal performance. In
this comprehensive guide, we'll explore the essential principles of database
design that every developer should master.

{/* truncate */}

---

## üìã Table of Contents

1. [Understanding Database Design](#understanding-database-design)
2. [Data Modeling Fundamentals](#data-modeling-fundamentals)
3. [Normalization Principles](#normalization-principles)
4. [Relationships & Foreign Keys](#relationships--foreign-keys)
5. [Indexing Strategies](#indexing-strategies)
6. [Primary & Composite Keys](#primary--composite-keys)
7. [Constraints & Data Integrity](#constraints--data-integrity)
8. [SQL vs NoSQL Design Patterns](#sql-vs-nosql-design-patterns)
9. [Performance Optimization](#performance-optimization)
10. [Database Security](#database-security)
11. [Migration Strategies](#migration-strategies)
12. [Common Pitfalls](#common-pitfalls)
13. [Design Patterns](#design-patterns)
14. [Real-World Examples](#real-world-examples)

---

## üèóÔ∏è Understanding Database Design {#understanding-database-design}

### **Why Database Design Matters**

```sql
-- Bad Design Example
CREATE TABLE user_orders (
  id INT,
  user_name VARCHAR(255),
  user_email VARCHAR(255),
  order_date DATE,
  product_name VARCHAR(255),
  product_price DECIMAL,
  quantity INT
);
-- Problems: Data duplication, integrity issues, complex queries

-- Good Design Example
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  price DECIMAL(10,2) NOT NULL
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
  id SERIAL PRIMARY KEY,
  order_id INT REFERENCES orders(id),
  product_id INT REFERENCES products(id),
  quantity INT NOT NULL
);
```

### **Database Design Phases**

1. **Requirements Analysis** - Understand business needs
2. **Conceptual Design** - High-level data model (ER diagrams)
3. **Logical Design** - Relational schema, normalization
4. **Physical Design** - Indexes, storage optimization
5. **Implementation** - SQL scripts, constraints
6. **Testing & Optimization** - Performance tuning

---

## üìä Data Modeling Fundamentals {#data-modeling-fundamentals}

### **Entity-Relationship Model (ER Model)**

#### **Entities**

- Real-world objects or concepts
- Examples: User, Product, Order, Customer

#### **Attributes**

- Properties of entities
- Examples: user.name, product.price, order.date

#### **Relationships**

- Associations between entities
- Types: One-to-One, One-to-Many, Many-to-Many

### **ER Diagram Notation**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Customer  ‚îÇ       ‚îÇ    Order    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ id (PK)     ‚îÇ1‚îÄ‚îÄ‚îÄ‚îÄ‚îÄN‚îÇ id (PK)     ‚îÇ
‚îÇ name        ‚îÇ       ‚îÇ customer_id ‚îÇ
‚îÇ email       ‚îÇ       ‚îÇ order_date  ‚îÇ
‚îÇ address     ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îÇ
       N
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇOrder_Item   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ order_id    ‚îÇ
‚îÇ product_id  ‚îÇ
‚îÇ quantity    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Conceptual Design Process**

1. **Identify Entities**
   - Nouns from requirements
   - Business concepts

2. **Identify Attributes**
   - Properties of entities
   - Data types and constraints

3. **Identify Relationships**
   - Cardinality (1:1, 1:N, N:M)
   - Optionality (required/optional)

4. **Create ER Diagram**
   - Visual representation
   - Validate with stakeholders

---

## üîÑ Normalization Principles {#normalization-principles}

### **What is Normalization?**

Normalization is the process of organizing data to minimize redundancy and
dependency issues.

### **Normal Forms**

#### **First Normal Form (1NF)**

**Rule:** No repeating groups or arrays in a table.

```sql
-- ‚ùå Not in 1NF
CREATE TABLE orders (
  id INT,
  customer_name VARCHAR(255),
  products VARCHAR(1000) -- "Product1,Product2,Product3"
);

-- ‚úÖ 1NF Compliant
CREATE TABLE orders (
  id INT,
  customer_name VARCHAR(255)
);

CREATE TABLE order_items (
  order_id INT,
  product_name VARCHAR(255),
  quantity INT
);
```

#### **Second Normal Form (2NF)**

**Rule:** In 1NF + No partial dependencies (non-key attributes depend on entire
primary key).

```sql
-- ‚ùå Not in 2NF (partial dependency)
CREATE TABLE enrollments (
  student_id INT,
  course_id INT,
  student_name VARCHAR(255), -- Depends only on student_id
  course_name VARCHAR(255),  -- Depends only on course_id
  grade CHAR(1),
  PRIMARY KEY (student_id, course_id)
);

-- ‚úÖ 2NF Compliant
CREATE TABLE students (
  student_id INT PRIMARY KEY,
  student_name VARCHAR(255)
);

CREATE TABLE courses (
  course_id INT PRIMARY KEY,
  course_name VARCHAR(255)
);

CREATE TABLE enrollments (
  student_id INT,
  course_id INT,
  grade CHAR(1),
  PRIMARY KEY (student_id, course_id),
  FOREIGN KEY (student_id) REFERENCES students(student_id),
  FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

#### **Third Normal Form (3NF)**

**Rule:** In 2NF + No transitive dependencies (non-key attributes don't depend
on other non-key attributes).

```sql
-- ‚ùå Not in 3NF (transitive dependency)
CREATE TABLE employees (
  employee_id INT PRIMARY KEY,
  employee_name VARCHAR(255),
  department_id INT,
  department_name VARCHAR(255), -- Depends on department_id
  department_location VARCHAR(255) -- Depends on department_id
);

-- ‚úÖ 3NF Compliant
CREATE TABLE departments (
  department_id INT PRIMARY KEY,
  department_name VARCHAR(255),
  department_location VARCHAR(255)
);

CREATE TABLE employees (
  employee_id INT PRIMARY KEY,
  employee_name VARCHAR(255),
  department_id INT,
  FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
```

### **Boyce-Codd Normal Form (BCNF)**

**Rule:** In 3NF + Every determinant is a candidate key.

### **When to Denormalize**

Sometimes denormalization is necessary for performance:

```sql
-- Normalized (3NF)
CREATE TABLE orders (id, customer_id, total);
CREATE TABLE customers (id, name, address);

-- Denormalized (for performance)
CREATE TABLE order_summary (
  order_id INT,
  customer_name VARCHAR(255),  -- Duplicated for faster queries
  customer_address TEXT,       -- Duplicated for faster queries
  order_total DECIMAL(10,2),
  order_date DATE
);
```

---

## üîó Relationships & Foreign Keys {#relationships--foreign-keys}

### **Relationship Types**

#### **One-to-One (1:1)**

Each entity instance relates to exactly one instance of another entity.

```sql
-- User Profile (1:1 with User)
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE user_profiles (
  id SERIAL PRIMARY KEY,
  user_id INT UNIQUE NOT NULL,
  bio TEXT,
  avatar_url VARCHAR(500),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

#### **One-to-Many (1:N)**

One entity instance relates to many instances of another entity.

```sql
-- Author and Books (1:N)
CREATE TABLE authors (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE
);

CREATE TABLE books (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  author_id INT NOT NULL,
  published_date DATE,
  FOREIGN KEY (author_id) REFERENCES authors(id) ON DELETE CASCADE
);
```

#### **Many-to-Many (N:M)**

Many instances of one entity relate to many instances of another entity.

```sql
-- Students and Courses (N:M)
CREATE TABLE students (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE
);

CREATE TABLE courses (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  code VARCHAR(20) UNIQUE
);

-- Junction table for N:M relationship
CREATE TABLE enrollments (
  student_id INT NOT NULL,
  course_id INT NOT NULL,
  enrollment_date DATE DEFAULT CURRENT_DATE,
  grade CHAR(1),
  PRIMARY KEY (student_id, course_id),
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE
);
```

### **Foreign Key Constraints**

```sql
-- Comprehensive foreign key example
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INT NOT NULL,
  order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  -- Foreign key with referential actions
  FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE RESTRICT    -- Prevent deletion if orders exist
    ON UPDATE CASCADE    -- Update customer_id if customer id changes
);
```

### **Referential Actions**

- **CASCADE**: Delete/update child rows when parent changes
- **RESTRICT**: Prevent operation if child rows exist
- **SET NULL**: Set foreign key to NULL when parent deleted
- **SET DEFAULT**: Set foreign key to default value
- **NO ACTION**: Allow violation temporarily (for deferred constraints)

---

## üîç Indexing Strategies {#indexing-strategies}

### **What is Indexing?**

Indexes are data structures that improve query performance by allowing faster
data retrieval.

### **Index Types**

#### **B-Tree Index (Default)**

```sql
-- Single column index
CREATE INDEX idx_users_email ON users(email);

-- Composite index
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- Unique index
CREATE UNIQUE INDEX idx_products_sku ON products(sku);
```

#### **Hash Index**

```sql
-- Fast equality comparisons (not range queries)
CREATE INDEX CONCURRENTLY idx_users_email_hash ON users USING hash(email);
```

#### **GIN Index (PostgreSQL)**

```sql
-- For arrays and full-text search
CREATE INDEX idx_posts_tags ON posts USING gin(tags);
```

#### **Full-Text Search Index**

```sql
-- PostgreSQL full-text search
CREATE INDEX idx_articles_content_fts ON articles
USING gin(to_tsvector('english', content));
```

### **Index Best Practices**

```sql
-- ‚úÖ Good: Index foreign keys
CREATE INDEX idx_orders_customer_id ON orders(customer_id);

-- ‚úÖ Good: Index WHERE clause columns
CREATE INDEX idx_products_category_price ON products(category, price);

-- ‚úÖ Good: Index ORDER BY columns
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);

-- ‚ùå Bad: Index every column
-- ‚ùå Bad: Index low-cardinality columns (gender, status flags)
-- ‚ùå Bad: Over-index (maintenance overhead)
```

### **Index Maintenance**

```sql
-- Monitor index usage
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- Remove unused indexes
DROP INDEX IF EXISTS unused_index;

-- Reindex for maintenance
REINDEX INDEX CONCURRENTLY idx_users_email;
```

---

## üóùÔ∏è Primary & Composite Keys {#primary--composite-keys}

### **Primary Key Types**

#### **Natural Keys**

```sql
-- Using existing data as primary key
CREATE TABLE countries (
  country_code CHAR(3) PRIMARY KEY, -- 'USA', 'IND', 'GBR'
  country_name VARCHAR(100) NOT NULL
);
```

#### **Surrogate Keys**

```sql
-- Auto-generated primary key
CREATE TABLE users (
  id SERIAL PRIMARY KEY,  -- Surrogate key
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL
);
```

#### **Composite Keys**

```sql
-- Multiple columns as primary key
CREATE TABLE user_permissions (
  user_id INT NOT NULL,
  permission_id INT NOT NULL,
  granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (user_id, permission_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (permission_id) REFERENCES permissions(id)
);
```

### **Choosing Primary Keys**

**Considerations:**

- **Stability**: Won't change over time
- **Uniqueness**: Guaranteed to be unique
- **Simplicity**: Easy to work with
- **Performance**: Efficient for joins and lookups

**Recommendations:**

- Use surrogate keys (auto-increment/serial) for most tables
- Use natural keys only when they are truly stable and meaningful
- Avoid composite keys unless necessary (junction tables)
- Consider UUIDs for distributed systems

---

## üõ°Ô∏è Constraints & Data Integrity {#constraints--data-integrity}

### **Constraint Types**

#### **NOT NULL Constraint**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### **UNIQUE Constraint**

```sql
-- Single column
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  sku VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL
);

-- Multiple columns
CREATE UNIQUE INDEX idx_users_email_active
ON users(email) WHERE is_active = true;
```

#### **CHECK Constraint**

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  price DECIMAL(10,2) NOT NULL CHECK (price > 0),
  stock_quantity INT NOT NULL CHECK (stock_quantity >= 0),
  discount_percent DECIMAL(5,2) CHECK (discount_percent BETWEEN 0 AND 100)
);
```

#### **DEFAULT Values**

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INT NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Triggers for Data Integrity**

```sql
-- Auto-update timestamp trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

---

## üÜö SQL vs NoSQL Design Patterns {#sql-vs-nosql-design-patterns}

### **SQL Databases (Relational)**

#### **When to Use SQL**

- Complex relationships between data
- ACID transactions required
- Data integrity is critical
- Complex queries and aggregations
- Structured, predictable data

#### **SQL Design Patterns**

```sql
-- Audit trail pattern
CREATE TABLE audit_log (
  id SERIAL PRIMARY KEY,
  table_name VARCHAR(50) NOT NULL,
  record_id INT NOT NULL,
  action VARCHAR(10) NOT NULL, -- INSERT, UPDATE, DELETE
  old_values JSONB,
  new_values JSONB,
  changed_by INT REFERENCES users(id),
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Soft delete pattern
CREATE TABLE articles (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  content TEXT,
  is_deleted BOOLEAN DEFAULT FALSE,
  deleted_at TIMESTAMP,
  deleted_by INT REFERENCES users(id)
);

-- Polymorphic associations
CREATE TABLE comments (
  id SERIAL PRIMARY KEY,
  content TEXT NOT NULL,
  commentable_type VARCHAR(50) NOT NULL, -- 'post', 'article', 'video'
  commentable_id INT NOT NULL,
  author_id INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **NoSQL Databases (Document/Graph)**

#### **When to Use NoSQL**

- Unstructured or semi-structured data
- High write loads
- Horizontal scaling needs
- Rapid schema evolution
- Real-time analytics

#### **NoSQL Design Patterns**

```javascript
// Document embedding (MongoDB)
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "user": {
    "name": "John Doe",
    "email": "john@example.com"
  },
  "orders": [
    {
      "orderId": "ORD-001",
      "items": [
        {"productId": "PROD-123", "quantity": 2, "price": 29.99}
      ],
      "total": 59.98,
      "status": "shipped"
    }
  ]
}

// Denormalized for performance
{
  "productId": "PROD-123",
  "name": "Wireless Headphones",
  "price": 99.99,
  "category": {
    "id": "CAT-001",
    "name": "Electronics"
  },
  "reviews": [
    {
      "userId": "USER-456",
      "userName": "Alice",
      "rating": 5,
      "comment": "Great sound quality!"
    }
  ]
}
```

### **Hybrid Approach**

```javascript
// Use both SQL and NoSQL together
// SQL for transactional data
// NoSQL for user sessions, cache, analytics

// PostgreSQL for core data
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL
);

// Redis for sessions
// user:123:sessions -> JSON object

// MongoDB for analytics
// { userId: 123, events: [...], lastActive: Date }
```

---

## ‚ö° Performance Optimization {#performance-optimization}

### **Query Optimization**

#### **EXPLAIN ANALYZE**

```sql
-- Analyze query performance
EXPLAIN ANALYZE
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2024-01-01'
GROUP BY u.id, u.name
HAVING COUNT(o.id) > 5
ORDER BY order_count DESC
LIMIT 10;
```

#### **Index Optimization**

```sql
-- Analyze slow queries
SELECT query, calls, total_time, mean_time, rows
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- Create appropriate indexes
CREATE INDEX CONCURRENTLY idx_orders_user_date
ON orders(user_id, created_at DESC);

CREATE INDEX CONCURRENTLY idx_products_category_price
ON products(category_id, price)
WHERE in_stock = true;
```

### **Database Partitioning**

```sql
-- Partition large tables by date
CREATE TABLE orders_y2024m01 PARTITION OF orders
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- Hash partitioning for even distribution
CREATE TABLE users PARTITION BY hash(id);
CREATE TABLE users_0 PARTITION OF users FOR VALUES WITH (modulus 4, remainder 0);
CREATE TABLE users_1 PARTITION OF users FOR VALUES WITH (modulus 4, remainder 1);
```

### **Connection Pooling**

```javascript
// Database connection pooling
const pool = new Pool({
  host: 'localhost',
  database: 'mydb',
  user: 'dbuser',
  password: 'dbpass',
  max: 20, // Maximum connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Use pooled connections
pool
  .query('SELECT * FROM users WHERE id = $1', [userId])
  .then(result => console.log(result.rows))
  .catch(err => console.error('Query error', err));
```

---

## üîí Database Security {#database-security}

### **Access Control**

```sql
-- Create roles with specific permissions
CREATE ROLE readonly_user;
GRANT CONNECT ON DATABASE myapp TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;

-- Application user with limited permissions
CREATE ROLE app_user WITH LOGIN PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE ON users, orders TO app_user;
GRANT USAGE ON SEQUENCE users_id_seq, orders_id_seq TO app_user;
```

### **Data Encryption**

```sql
-- Encrypt sensitive data
CREATE EXTENSION pgcrypto;

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  encrypted_ssn BYTEA,  -- Encrypted Social Security Number
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Encrypt/decrypt functions
INSERT INTO users (email, encrypted_ssn)
VALUES ('user@example.com', pgp_sym_encrypt('123-45-6789', 'encryption_key'));

SELECT email, pgp_sym_decrypt(encrypted_ssn, 'encryption_key') as ssn
FROM users WHERE id = 1;
```

### **SQL Injection Prevention**

```javascript
// ‚úÖ Parameterized queries
const { rows } = await pool.query(
  'SELECT * FROM users WHERE email = $1 AND status = $2',
  [userEmail, 'active'],
);

// ‚ùå Dangerous string concatenation
const dangerousQuery = `SELECT * FROM users WHERE email = '${userEmail}'`;
// Allows SQL injection: ' OR '1'='1
```

---

## üîÑ Migration Strategies {#migration-strategies}

### **Database Versioning**

```javascript
// Migration file structure
migrations/
‚îú‚îÄ‚îÄ 001_initial_schema.sql
‚îú‚îÄ‚îÄ 002_add_user_profiles.sql
‚îú‚îÄ‚îÄ 003_create_orders_table.sql
‚îú‚îÄ‚îÄ 004_add_indexes.sql
‚îî‚îÄ‚îÄ 005_migrate_legacy_data.sql
```

### **Migration Best Practices**

```sql
-- Up migration
-- migrations/003_add_email_verification.sql
BEGIN;

ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN verification_token VARCHAR(255);
CREATE INDEX CONCURRENTLY idx_users_verification_token ON users(verification_token);

COMMIT;

-- Down migration (for rollbacks)
-- migrations/003_down_add_email_verification.sql
BEGIN;

DROP INDEX IF EXISTS idx_users_verification_token;
ALTER TABLE users DROP COLUMN IF EXISTS verification_token;
ALTER TABLE users DROP COLUMN IF EXISTS email_verified;

COMMIT;
```

### **Zero-Downtime Migrations**

```sql
-- Add column without locking table
ALTER TABLE users ADD COLUMN new_email VARCHAR(255);

-- Populate new column
UPDATE users SET new_email = email WHERE new_email IS NULL;

-- Add constraints and indexes
ALTER TABLE users ALTER COLUMN new_email SET NOT NULL;
CREATE UNIQUE INDEX CONCURRENTLY idx_users_new_email ON users(new_email);

-- Switch to new column
ALTER TABLE users DROP COLUMN email;
ALTER TABLE users RENAME COLUMN new_email TO email;
```

---

## üö´ Common Pitfalls {#common-pitfalls}

### **1. Poor Normalization**

```sql
-- ‚ùå Over-normalization (too many joins)
CREATE TABLE countries (id, name);
CREATE TABLE states (id, name, country_id);
CREATE TABLE cities (id, name, state_id);
CREATE TABLE addresses (id, street, city_id, postal_code);

-- Query requires 4 joins!
SELECT a.street, c.name as city, s.name as state, co.name as country
FROM addresses a
JOIN cities c ON a.city_id = c.id
JOIN states s ON c.state_id = s.id
JOIN countries co ON s.country_id = co.id;

-- ‚úÖ Balanced approach
CREATE TABLE addresses (
  id SERIAL PRIMARY KEY,
  street VARCHAR(255),
  city VARCHAR(100),
  state VARCHAR(100),
  country VARCHAR(100),
  postal_code VARCHAR(20)
);
-- Simple queries, acceptable redundancy
```

### **2. Missing Indexes**

```sql
-- ‚ùå Slow queries without indexes
SELECT * FROM orders WHERE customer_id = 123 AND created_at > '2024-01-01';
-- Table scan on millions of rows

-- ‚úÖ Fast queries with proper indexes
CREATE INDEX idx_orders_customer_date ON orders(customer_id, created_at);
```

### **3. Large VARCHAR Fields**

```sql
-- ‚ùå Inefficient for large text
CREATE TABLE articles (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500),
  content TEXT  -- Can be very large
);

-- ‚úÖ Use appropriate data types
CREATE TABLE articles (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500),
  content TEXT,
  summary VARCHAR(1000),  -- Reasonable limit
  word_count INT
);
```

### **4. Ignoring NULL Values**

```sql
-- ‚ùå NULL handling issues
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),           -- Allows NULL
  email VARCHAR(255) UNIQUE    -- Allows NULL (breaks uniqueness)
);

-- ‚úÖ Proper NULL handling
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  phone VARCHAR(20) NULL,      -- Explicitly allow NULL
  deleted_at TIMESTAMP NULL
);
```

### **5. Circular Dependencies**

```sql
-- ‚ùå Circular foreign keys
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  manager_id INT REFERENCES employees(id)  -- References itself
);

-- ‚úÖ Proper hierarchy
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  manager_id INT,
  FOREIGN KEY (manager_id) REFERENCES employees(id)
    ON DELETE SET NULL  -- Avoid cascade issues
);
```

---

## üé® Design Patterns {#design-patterns}

### **Soft Delete Pattern**

```sql
CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  content TEXT,
  is_deleted BOOLEAN DEFAULT FALSE,
  deleted_at TIMESTAMP,
  deleted_by INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Instead of DELETE
UPDATE posts SET
  is_deleted = TRUE,
  deleted_at = CURRENT_TIMESTAMP,
  deleted_by = $1
WHERE id = $2;

-- Query active posts only
SELECT * FROM posts WHERE is_deleted = FALSE;
```

### **Audit Trail Pattern**

```sql
CREATE TABLE audit_trail (
  id SERIAL PRIMARY KEY,
  table_name VARCHAR(50) NOT NULL,
  record_id INT NOT NULL,
  action VARCHAR(10) NOT NULL, -- INSERT, UPDATE, DELETE
  old_values JSONB,
  new_values JSONB,
  changed_by INT REFERENCES users(id),
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Trigger to populate audit trail
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO audit_trail (table_name, record_id, action, new_values, changed_by)
    VALUES (TG_TABLE_NAME, NEW.id, TG_OP, row_to_json(NEW), NEW.updated_by);
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO audit_trail (table_name, record_id, action, old_values, new_values, changed_by)
    VALUES (TG_TABLE_NAME, NEW.id, TG_OP, row_to_json(OLD), row_to_json(NEW), NEW.updated_by);
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO audit_trail (table_name, record_id, action, old_values, changed_by)
    VALUES (TG_TABLE_NAME, OLD.id, TG_OP, row_to_json(OLD), OLD.updated_by);
  END IF;
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
```

### **Versioning Pattern**

```sql
-- Document versioning
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  current_version_id INT
);

CREATE TABLE document_versions (
  id SERIAL PRIMARY KEY,
  document_id INT REFERENCES documents(id),
  title VARCHAR(500),
  content TEXT,
  version_number INT NOT NULL,
  created_by INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(document_id, version_number)
);

-- Retrieve latest version
SELECT dv.* FROM documents d
JOIN document_versions dv ON d.current_version_id = dv.id
WHERE d.id = $1;
```

---

## üåç Real-World Examples {#real-world-examples}

### **E-commerce Database Design**

```sql
-- Core entities
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(500) NOT NULL,
  description TEXT,
  price DECIMAL(10,2) NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  category_id INT REFERENCES categories(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  status VARCHAR(50) DEFAULT 'pending',
  total_amount DECIMAL(10,2) NOT NULL,
  shipping_address JSONB,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
  id SERIAL PRIMARY KEY,
  order_id INT REFERENCES orders(id),
  product_id INT REFERENCES products(id),
  quantity INT NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  UNIQUE(order_id, product_id)
);

-- Indexes for performance
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_order_items_order ON order_items(order_id);
```

### **Social Media Platform**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  profile_picture_url VARCHAR(500),
  bio TEXT,
  follower_count INT DEFAULT 0,
  following_count INT DEFAULT 0
);

CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  content TEXT NOT NULL,
  media_urls JSONB,  -- Array of image/video URLs
  like_count INT DEFAULT 0,
  comment_count INT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE follows (
  follower_id INT REFERENCES users(id),
  following_id INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (follower_id, following_id),
  CHECK (follower_id != following_id)  -- Can't follow yourself
);

-- Partial indexes for better performance
CREATE INDEX idx_posts_user_created ON posts(user_id, created_at DESC);
CREATE INDEX idx_posts_created ON posts(created_at DESC) WHERE created_at > CURRENT_DATE - INTERVAL '30 days';
```

### **Content Management System**

```sql
CREATE TABLE content_types (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) UNIQUE NOT NULL, -- 'article', 'page', 'product'
  description TEXT
);

CREATE TABLE content (
  id SERIAL PRIMARY KEY,
  type_id INT REFERENCES content_types(id),
  title VARCHAR(500) NOT NULL,
  slug VARCHAR(255) UNIQUE NOT NULL,
  content TEXT,
  meta_description VARCHAR(300),
  status VARCHAR(20) DEFAULT 'draft', -- 'draft', 'published', 'archived'
  published_at TIMESTAMP,
  created_by INT REFERENCES users(id),
  updated_by INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Flexible metadata system
CREATE TABLE content_metadata (
  id SERIAL PRIMARY KEY,
  content_id INT REFERENCES content(id),
  meta_key VARCHAR(100) NOT NULL,
  meta_value TEXT,
  UNIQUE(content_id, meta_key)
);

-- Full-text search capability
CREATE INDEX idx_content_fts ON content
USING gin(to_tsvector('english', title || ' ' || content));
```

---

## üéØ Final Thoughts

Database design is both an art and a science that requires careful consideration
of:

- **Data Relationships**: Understanding how entities relate to each other
- **Performance**: Indexing, query optimization, and scaling strategies
- **Data Integrity**: Constraints, normalization, and validation rules
- **Maintainability**: Clear schema design and documentation
- **Future-Proofing**: Designing for growth and evolution

**Key Principles to Remember:**

1. **Normalize, but don't over-normalize** - Balance between integrity and
   performance
2. **Index wisely** - Speed up queries without over-indexing
3. **Choose the right data types** - Optimize storage and performance
4. **Plan for growth** - Design for scalability from day one
5. **Document everything** - Schema changes, business rules, constraints
6. **Test thoroughly** - Performance, edge cases, concurrent access
7. **Monitor and optimize** - Use query analysis and performance monitoring

**Database design decisions have long-term impacts on application performance,
maintainability, and scalability. Invest time in good design upfront to avoid
costly refactoring later.**

**Happy database designing! üóÑÔ∏è**

_Resources for further learning:_

- [Database Design for Mere Mortals](https://www.amazon.com/Database-Design-Mere-Mortals-Hands/dp/0321884493)
- [SQL Performance Explained](https://sql-performance-explained.com/)
- [Database Design Patterns](https://www.amazon.com/Database-Design-Patterns-Experience-Classics/dp/0321555628)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
