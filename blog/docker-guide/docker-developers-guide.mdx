---
title: 'Docker for Developers: Complete Guide to Containerization'
description: 'Master Docker from basics to advanced usage. Learn containers, images, Docker Compose, multi-stage builds, and best practices for development workflows.'
slug: docker-developers-guide
authors: praveen
image: /img/blog/react.png
date: 2025-10-18
keywords: ['docker', 'containers', 'dockerfile', 'docker compose', 'containerization', 'devops', 'development environment', 'microservices']
tags: [docker, containers, devops, development, containerization, dockerfile, docker-compose]
---

import CodeBlock from '@theme/CodeBlock';

# ğŸ³ Docker for Developers: Complete Guide to Containerization

Docker has revolutionized software development by introducing containerization - a lightweight, portable way to package and run applications. Whether you're a frontend developer, backend engineer, or DevOps specialist, understanding Docker is essential for modern development workflows. This comprehensive guide takes you from Docker basics to advanced container orchestration.

{/* truncate */}

---

## ğŸ“‹ Table of Contents

1. [What is Docker?](#what-is-docker)
2. [Why Use Docker?](#why-use-docker)
3. [Docker Architecture](#docker-architecture)
4. [Installing Docker](#installing-docker)
5. [Docker Images & Containers](#docker-images--containers)
6. [Writing Dockerfiles](#writing-dockerfiles)
7. [Docker Commands](#docker-commands)
8. [Docker Compose](#docker-compose)
9. [Multi-Stage Builds](#multi-stage-builds)
10. [Development Workflows](#development-workflows)
11. [Docker Best Practices](#docker-best-practices)
12. [Debugging Containers](#debugging-containers)
13. [Security Considerations](#security-considerations)
14. [CI/CD Integration](#cicd-integration)
15. [Real-World Examples](#real-world-examples)

---

## ğŸ³ What is Docker? {#what-is-docker}

### **Containerization vs Virtualization**

```bash
# Traditional Virtualization
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Host Operating System       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Hypervisor (VirtualBox/VMware)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚    Guest OS                    â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚   Application + Dependencies   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ Heavy (GBs)         â†‘ Slow startup

# Docker Containerization
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Host Operating System       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        Docker Engine                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚   Container Runtime (runc)      â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚   Application + Dependencies   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ Light (MBs)         â†‘ Fast startup
```

### **Key Docker Concepts**

- **Images**: Read-only templates containing application code and dependencies
- **Containers**: Running instances of images (like objects are instances of classes)
- **Dockerfile**: Instructions to build an image
- **Registry**: Repository for storing and sharing images (Docker Hub, AWS ECR, etc.)
- **Volumes**: Persistent data storage for containers
- **Networks**: Communication between containers

---

## ğŸ¯ Why Use Docker? {#why-use-docker}

### **Development Benefits**

#### **1. Environment Consistency**
```bash
# Problem: "It works on my machine!"
# Solution: Same environment everywhere

# Development
docker run -p 3000:3000 myapp:dev

# Staging
docker run -p 3000:3000 myapp:staging

# Production
docker run -p 80:3000 myapp:latest
```

#### **2. Rapid Setup**
```bash
# Traditional setup (hours/days)
# 1. Install Node.js
# 2. Install dependencies
# 3. Configure environment
# 4. Debug version conflicts
# 5. Repeat for team members

# Docker setup (minutes)
docker run -d -p 3000:3000 myapp:latest
```

#### **3. Isolation & Dependency Management**
```bash
# Run different Node.js versions simultaneously
docker run -it node:14-alpine node --version  # Node 14
docker run -it node:16-alpine node --version  # Node 16
docker run -it node:18-alpine node --version  # Node 18
```

### **Business Benefits**

- **Faster deployment cycles**
- **Reduced infrastructure costs**
- **Improved scalability**
- **Easier rollbacks**
- **Better resource utilization**

---

## ğŸ—ï¸ Docker Architecture {#docker-architecture}

### **Docker Components**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Docker Client                            â”‚
â”‚  (CLI, Docker Desktop, API)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Docker Daemon                               â”‚
â”‚  (dockerd) - Manages containers, images, networks, volumes  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”‚                                                         â”‚
â”‚  â”œâ”€â”€ Container Runtime (containerd/runc)                   â”‚
â”‚  â”œâ”€â”€ Image Management                                      â”‚
â”‚  â”œâ”€â”€ Network Management                                    â”‚
â”‚  â””â”€â”€ Volume Management                                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Docker Registry                             â”‚
â”‚  (Docker Hub, AWS ECR, Google GCR, etc.)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Docker Desktop vs Docker Engine**

```bash
# Docker Desktop (GUI + Engine)
# - User-friendly interface
# - Kubernetes integration
# - Docker Compose built-in
# - Resource management
# - Extensions marketplace

# Docker Engine (CLI-only)
# - Lightweight
# - Server environments
# - CI/CD pipelines
# - Headless operation
```

---

## ğŸ’¾ Installing Docker {#installing-docker}

### **Docker Desktop (Recommended for Development)**

#### **macOS**
```bash
# Using Homebrew
brew install --cask docker

# Or download from docker.com
# https://docs.docker.com/desktop/install/mac-install/
```

#### **Windows**
```bash
# Using Chocolatey
choco install docker-desktop

# Or download from docker.com
# https://docs.docker.com/desktop/install/windows-install/
```

#### **Linux**
```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install docker.io docker-compose
sudo systemctl start docker
sudo systemctl enable docker

# Add user to docker group
sudo usermod -aG docker $USER
```

### **Verify Installation**
```bash
# Check Docker version
docker --version
docker version

# Test installation
docker run hello-world

# Check Docker Compose
docker-compose --version
# or
docker compose version
```

---

## ğŸ“¦ Docker Images & Containers {#docker-images--containers}

### **Understanding Images**

```bash
# Docker images are layered filesystems
# Each layer represents a change/instruction

# Example: Node.js application layers
â”‚ Layer 1: Base OS (Alpine Linux)
â”‚ Layer 2: Node.js runtime
â”‚ Layer 3: Application dependencies (package.json)
â”‚ Layer 4: Source code
â”‚ Layer 5: Build artifacts
â”” Layer 6: Runtime configuration
```

### **Working with Images**

```bash
# List images
docker images
docker image ls

# Pull image from registry
docker pull nginx:latest
docker pull node:18-alpine

# Build image from Dockerfile
docker build -t myapp:1.0 .

# Tag image
docker tag myapp:1.0 myapp:latest
docker tag myapp:1.0 myregistry.com/myapp:1.0

# Push image to registry
docker push myregistry.com/myapp:1.0

# Remove images
docker rmi myapp:1.0
docker image prune -f
```

### **Container Lifecycle**

```bash
# Create and run container
docker run -d --name web nginx:latest

# List running containers
docker ps

# List all containers (including stopped)
docker ps -a

# Stop container
docker stop web

# Start stopped container
docker start web

# Restart container
docker restart web

# Remove container
docker rm web

# Remove all stopped containers
docker container prune -f
```

### **Container Logs & Inspection**

```bash
# View container logs
docker logs web
docker logs -f web  # Follow logs

# Inspect container details
docker inspect web

# Execute commands in running container
docker exec -it web /bin/bash
docker exec web ps aux

# Monitor resource usage
docker stats
docker stats web
```

---

## ğŸ“ Writing Dockerfiles {#writing-dockerfiles}

### **Basic Dockerfile Structure**

```dockerfile
# Use official Node.js runtime as base image
FROM node:18-alpine

# Set working directory in container
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Define startup command
CMD ["npm", "start"]
```

### **Dockerfile Best Practices**

#### **1. Use Specific Base Images**
```dockerfile
# âœ… Specific version
FROM node:18.17.0-alpine3.18

# âŒ Latest tag (unpredictable)
FROM node:latest
```

#### **2. Minimize Layers**
```dockerfile
# âŒ Multiple RUN commands create multiple layers
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim

# âœ… Combine commands to reduce layers
RUN apt-get update && \
    apt-get install -y curl vim && \
    rm -rf /var/lib/apt/lists/*
```

#### **3. Use .dockerignore**
```
# .dockerignore file
node_modules
.git
.gitignore
README.md
.env
.nyc_output
coverage
```

#### **4. Order Instructions for Caching**
```dockerfile
# âœ… Dependencies first (cached unless package.json changes)
COPY package*.json ./
RUN npm ci

# âœ… Source code last (changes frequently)
COPY . .
```

### **Common Dockerfile Patterns**

#### **Node.js Application**
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies only when package files change
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

USER nextjs

EXPOSE 3000

CMD ["npm", "start"]
```

#### **Python Application**
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["python", "app.py"]
```

#### **Go Application**
```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .

EXPOSE 8080

CMD ["./main"]
```

---

## ğŸ™ Docker Commands {#docker-commands}

### **Essential Commands**

```bash
# Container Management
docker run [OPTIONS] IMAGE [COMMAND]  # Run container
docker ps                              # List running containers
docker ps -a                          # List all containers
docker stop CONTAINER                 # Stop container
docker start CONTAINER                # Start container
docker restart CONTAINER              # Restart container
docker rm CONTAINER                   # Remove container
docker logs CONTAINER                 # View logs
docker exec -it CONTAINER COMMAND     # Execute in container

# Image Management
docker images                         # List images
docker build -t TAG .                 # Build image
docker pull IMAGE                     # Pull image
docker push IMAGE                     # Push image
docker rmi IMAGE                      # Remove image

# System Management
docker system df                      # Show disk usage
docker system prune                   # Remove unused data
docker volume ls                      # List volumes
docker network ls                     # List networks
```

### **Advanced Commands**

```bash
# Run with environment variables
docker run -e NODE_ENV=production -e PORT=3000 myapp

# Mount volumes
docker run -v $(pwd):/app -v /app/node_modules myapp

# Port mapping
docker run -p 3000:3000 myapp
docker run -p 127.0.0.1:3000:3000 myapp  # Bind to localhost only

# Resource limits
docker run --memory=512m --cpus=0.5 myapp

# Health checks
docker run --health-cmd="curl -f http://localhost:3000/health" \
           --health-interval=30s \
           --health-timeout=3s \
           --health-retries=3 \
           myapp
```

---

## ğŸ™ Docker Compose {#docker-compose}

### **What is Docker Compose?**

Docker Compose allows you to define and run multi-container Docker applications using a YAML file.

### **Basic docker-compose.yml**

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - db

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=mypass
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
```

### **Docker Compose Commands**

```bash
# Start services
docker-compose up
docker-compose up -d  # Detached mode

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up --build

# View logs
docker-compose logs
docker-compose logs web

# Execute commands
docker-compose exec web bash
docker-compose exec db psql -U myuser -d myapp

# Scale services
docker-compose up --scale web=3

# Stop and remove everything
docker-compose down -v --rmi all
```

### **Advanced Docker Compose**

```yaml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://myuser:mypass@db:5432/myapp
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=mypass
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myuser -d myapp"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:

networks:
  default:
    driver: bridge
```

---

## ğŸ—ï¸ Multi-Stage Builds {#multi-stage-builds}

### **What are Multi-Stage Builds?**

Multi-stage builds allow you to use multiple `FROM` statements in a Dockerfile, copying artifacts from one stage to another, keeping the final image small.

### **Node.js Multi-Stage Build**

```dockerfile
# Build stage
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies)
RUN npm ci

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create app user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

WORKDIR /app

# Copy built application from builder stage
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist

# Change to non-root user
USER nextjs

EXPOSE 3000

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "run", "start:prod"]
```

### **Python Multi-Stage Build**

```dockerfile
# Build stage
FROM python:3.11-slim AS builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim AS production

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv

# Make sure we use venv
ENV PATH="/opt/venv/bin:$PATH"

WORKDIR /app

# Copy application code
COPY . .

EXPOSE 8000

CMD ["python", "app.py"]
```

### **Go Multi-Stage Build**

```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the binary
RUN CGO_ENABLED=0 GOOS=linux go build \
    -a -installsuffix cgo \
    -o main \
    -ldflags="-w -s" \
    .

# Production stage
FROM scratch

# Copy SSL certificates for HTTPS
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy the binary
COPY --from=builder /app/main /

# Expose port
EXPOSE 8080

# Run the binary
CMD ["/main"]
```

---

## ğŸ”„ Development Workflows {#development-workflows}

### **Development Container Setup**

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    command: npm run dev

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp_dev
      - POSTGRES_USER=dev
      - POSTGRES_PASSWORD=devpass
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_dev_data:
```

### **Hot Reload Setup**

```dockerfile
# Dockerfile.dev
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev)
RUN npm install

# Copy source code
COPY . .

EXPOSE 3000

# Use polling for file watching in containers
ENV CHOKIDAR_USEPOLLING=true

CMD ["npm", "run", "dev"]
```

### **Debugging in Containers**

```bash
# Run container with debugging
docker run -d --name debug-app \
  -p 3000:3000 \
  -p 9229:9229 \
  --env NODE_ENV=development \
  myapp

# Attach debugger
docker exec -it debug-app /bin/bash

# Or use VS Code debugging
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Docker: Attach to Node",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "address": "localhost",
      "localRoot": "${workspaceFolder}",
      "remoteRoot": "/app",
      "protocol": "inspector"
    }
  ]
}
```

---

## ğŸ¯ Docker Best Practices {#docker-best-practices}

### **Image Optimization**

#### **1. Use Appropriate Base Images**
```dockerfile
# âœ… Alpine for small size
FROM node:18-alpine

# âœ… Distroless for security
FROM gcr.io/distroless/nodejs:18

# âŒ Ubuntu for Node.js (unnecessarily large)
FROM ubuntu:20.04
RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
RUN apt-get install -y nodejs
```

#### **2. Minimize Image Layers**
```dockerfile
# âœ… Single layer for multiple operations
RUN apt-get update && \
    apt-get install -y curl vim && \
    rm -rf /var/lib/apt/lists/*

# âŒ Multiple layers
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim
RUN rm -rf /var/lib/apt/lists/*
```

#### **3. Leverage Build Cache**
```dockerfile
# âœ… Dependencies first
COPY package*.json ./
RUN npm ci

# âœ… Source code last
COPY . .
```

### **Security Best Practices**

#### **1. Run as Non-Root User**
```dockerfile
# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Copy and set ownership
COPY --chown=appuser:appuser . /app

# Switch to non-root user
USER appuser
```

#### **2. Use Specific Image Tags**
```dockerfile
# âœ… Specific version
FROM node:18.17.0-alpine3.18

# âŒ Mutable tags
FROM node:latest
FROM alpine:latest
```

#### **3. Minimize Attack Surface**
```dockerfile
# Remove unnecessary packages
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean
```

### **Performance Optimization**

#### **1. Multi-Stage Builds**
```dockerfile
FROM node:18-alpine AS builder
# Build stage

FROM node:18-alpine AS production
# Production stage with only necessary files
```

#### **2. Layer Caching**
```dockerfile
# Cache dependencies
COPY package*.json ./
RUN npm ci

# Add source code after dependencies
COPY . .
```

#### **3. Use .dockerignore**
```
node_modules
.git
.env
*.log
coverage/
.nyc_output/
```

---

## ğŸ” Debugging Containers {#debugging-containers}

### **Common Debugging Commands**

```bash
# Check container status
docker ps -a

# View logs
docker logs container_name
docker logs -f container_name  # Follow logs

# Inspect container
docker inspect container_name

# Execute shell in container
docker exec -it container_name /bin/bash
docker exec -it container_name sh  # For Alpine

# Check resource usage
docker stats
docker stats container_name

# View container processes
docker top container_name
```

### **Debugging Node.js Applications**

```bash
# Run with debugging enabled
docker run -d \
  --name debug-app \
  -p 3000:3000 \
  -p 9229:9229 \
  -e NODE_ENV=development \
  myapp

# Attach to debugger
docker exec -it debug-app node --inspect-brk=0.0.0.0:9229 app.js
```

### **Network Debugging**

```bash
# Check network connectivity
docker exec container_name ping google.com

# Inspect network
docker network ls
docker network inspect bridge

# Test port connectivity
docker exec container_name nc -zv host.docker.internal 5432
```

### **Volume Debugging**

```bash
# Check volume contents
docker run --rm -v myvolume:/data alpine ls -la /data

# Inspect volume
docker volume ls
docker volume inspect myvolume
```

---

## ğŸ”’ Security Considerations {#security-considerations}

### **Container Security Best Practices**

#### **1. Image Security**
```bash
# Scan images for vulnerabilities
docker scan myimage

# Use trusted base images
FROM node:18-alpine  # Official, maintained image

# Avoid running as root
USER node
```

#### **2. Secrets Management**
```bash
# âŒ Don't put secrets in image
ENV API_KEY=secret123

# âœ… Use environment variables
docker run -e API_KEY=$API_KEY myapp

# âœ… Use Docker secrets (Swarm)
echo "secret" | docker secret create my_secret -
```

#### **3. Network Security**
```bash
# Don't expose unnecessary ports
docker run -p 80:3000 myapp  # Only expose needed ports

# Use internal networks
docker network create myapp_network
docker run --network myapp_network myapp
```

### **Docker Security Tools**

```bash
# Scan images
docker scan myimage

# Check for vulnerabilities
trivy image myimage

# Lint Dockerfiles
dockerfilelint Dockerfile

# Security scanning
clair-scanner myimage
```

---

## ğŸ”„ CI/CD Integration {#cicd-integration}

### **GitHub Actions with Docker**

```yaml
# .github/workflows/docker.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Build Docker image
      run: docker build -t myapp:${{ github.sha }} .

    - name: Run tests
      run: |
        docker run --rm myapp:${{ github.sha }} npm test

    - name: Push to registry
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker tag myapp:${{ github.sha }} myapp:latest
        docker push myapp:latest
```

### **Docker in Jenkins Pipeline**

```groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                script {
                    docker.build("myapp:${env.BUILD_ID}")
                }
            }
        }

        stage('Test') {
            steps {
                script {
                    docker.image("myapp:${env.BUILD_ID}").inside {
                        sh 'npm test'
                    }
                }
            }
        }

        stage('Deploy') {
            steps {
                script {
                    docker.withRegistry('https://registry.example.com', 'registry-credentials') {
                        docker.image("myapp:${env.BUILD_ID}").push('latest')
                    }
                }
            }
        }
    }
}
```

---

## ğŸŒŸ Real-World Examples {#real-world-examples}

### **Full-Stack Application**

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://api:8000
    depends_on:
      - api

  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/myapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### **Microservices Architecture**

```yaml
version: '3.8'

services:
  api-gateway:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - auth-service
      - user-service
      - product-service

  auth-service:
    build: ./auth-service
    environment:
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - auth-db

  user-service:
    build: ./user-service
    environment:
      - DATABASE_URL=postgresql://user:pass@user-db:5432/userdb
    depends_on:
      - user-db

  product-service:
    build: ./product-service
    environment:
      - DATABASE_URL=postgresql://user:pass@product-db:5432/productdb
    depends_on:
      - product-db

  auth-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=authdb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass

  user-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=userdb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass

  product-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=productdb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
```

---

## ğŸ¯ Final Thoughts

Docker has transformed software development by providing consistent, portable, and efficient containerization. Mastering Docker is essential for modern developers working on complex applications.

**Key Takeaways:**

1. **Start Small**: Begin with simple containers and gradually adopt advanced features
2. **Security First**: Always follow security best practices
3. **Optimize Images**: Use multi-stage builds and appropriate base images
4. **Compose for Development**: Use Docker Compose for local development
5. **Automate Everything**: Integrate Docker into your CI/CD pipelines
6. **Monitor & Debug**: Learn to troubleshoot container issues effectively
7. **Stay Updated**: Docker evolves rapidly - keep learning!

**Docker Mastery Roadmap:**

- **Beginner**: Basic containers, images, Dockerfiles
- **Intermediate**: Docker Compose, volumes, networking
- **Advanced**: Multi-stage builds, orchestration, security
- **Expert**: Custom images, performance optimization, production deployments

**Remember**: Containers are not virtual machines. They share the host kernel and are designed for running single processes or microservices.

**Happy containerizing! ğŸ³**

*Resources for further learning:*
- [Docker Documentation](https://docs.docker.com/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Awesome Docker](https://github.com/veggiemonk/awesome-docker)
- [Docker Compose Documentation](https://docs.docker.com/compose/)
- [Docker Security Best Practices](https://docs.docker.com/develop/security/)
