---
id: shadow-dom
title: Shadow DOM - Encapsulated Component Styling
description:
  Master Shadow DOM for creating encapsulated, reusable web components with
  isolated styles and behavior.
keywords:
  [
    shadow dom,
    dom encapsulation,
    web components,
    style isolation,
    css scoping,
    component styling,
    shadow root,
  ]
tags: [HTML, ShadowDOM, Encapsulation, CSS, WebComponents]
sidebar_position: 12
---

# üåë Shadow DOM

Shadow DOM provides encapsulation for web components, allowing you to create
isolated DOM trees with their own styles and behavior that don't interfere with
the rest of the document.

## üìñ What is Shadow DOM?

Shadow DOM is a web standard that allows you to attach a hidden, separate DOM to
an element. This separate DOM is called the "shadow DOM" and the element it's
attached to is called the "shadow host".

### Key Benefits:

- **Style Encapsulation**: Styles inside shadow DOM don't leak out, and external
  styles don't affect shadow DOM
- **DOM Isolation**: Shadow DOM elements are not accessible via regular DOM
  queries from outside
- **Scoped CSS**: CSS selectors are scoped to the shadow DOM tree
- **Simplified CSS**: No need for complex selectors to avoid conflicts

---

## üèóÔ∏è Creating Shadow DOM

### Basic Shadow DOM

```html
<div id="host"></div>

<script>
  const host = document.getElementById('host');

  // Create shadow root
  const shadow = host.attachShadow({ mode: 'open' });

  // Add content to shadow DOM
  shadow.innerHTML = `
    <style>
      .shadow-content {
        color: blue;
        font-size: 20px;
        padding: 10px;
        border: 2px solid blue;
      }
    </style>

    <div class="shadow-content">
      This content is inside Shadow DOM!
    </div>
  `;

  console.log(shadow); // ShadowRoot
  console.log(host.shadowRoot); // Same ShadowRoot
</script>
```

### Shadow DOM Modes

```javascript
class ShadowModes extends HTMLElement {
  constructor() {
    super();

    // Open mode: shadowRoot accessible via element.shadowRoot
    const openShadow = this.attachShadow({ mode: 'open' });
    openShadow.innerHTML = '<p>Open Shadow DOM - accessible</p>';

    // Closed mode: shadowRoot not accessible
    // const closedShadow = this.attachShadow({ mode: 'closed' });
    // closedShadow.innerHTML = '<p>Closed Shadow DOM - not accessible</p>';
  }
}

customElements.define('shadow-modes', ShadowModes);

// Usage
const element = document.querySelector('shadow-modes');
console.log(element.shadowRoot); // ShadowRoot (open mode)
// console.log(element.shadowRoot); // null (closed mode)
```

---

## üé® Style Encapsulation

### Styles Don't Leak Out

```html
<style>
  /* This style affects regular DOM only */
  .content {
    color: red;
    font-size: 16px;
  }
</style>

<div class="content">Regular DOM content (red)</div>

<shadow-host></shadow-host>

<script>
  class ShadowHost extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* This style only affects shadow DOM */
          .content {
            color: blue;
            font-size: 24px;
          }
        </style>

        <div class="content">Shadow DOM content (blue)</div>
      `;
    }
  }

  customElements.define('shadow-host', ShadowHost);
</script>
```

### External Styles Don't Affect Shadow DOM

```html
<style>
  /* Global styles don't affect shadow DOM */
  h1 {
    color: red;
  }
  .shadow-host {
    border: 5px solid red;
  }
</style>

<shadow-isolated></shadow-isolated>

<script>
  class ShadowIsolated extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Shadow DOM styles are completely isolated */
          h1 {
            color: blue;
            border: 2px solid blue;
          }
        </style>

        <h1>Shadow DOM Heading</h1>
        <p>This heading ignores external CSS rules.</p>
      `;
    }
  }

  customElements.define('shadow-isolated', ShadowIsolated);
</script>
```

---

## üéØ Shadow DOM Selectors

### :host Selector

```html
<host-selector></host-selector>

<script>
  class HostSelector extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Style the host element itself */
          :host {
            display: block;
            border: 3px solid green;
            padding: 10px;
            margin: 10px 0;
          }

          /* Style host when it has a specific class */
          :host(.highlighted) {
            border-color: red;
            background-color: lightyellow;
          }

          /* Style host based on its state */
          :host(:hover) {
            border-color: blue;
            cursor: pointer;
          }

          /* Style host based on context */
          :host(:focus-within) {
            outline: 2px solid orange;
          }

          .content {
            color: green;
            font-weight: bold;
          }
        </style>

        <div class="content">Content inside :host</div>
      `;
    }
  }

  customElements.define('host-selector', HostSelector);
</script>

<style>
  /* Apply class to host */
  host-selector.highlighted {
    /* This won't affect the component */
  }
</style>

<!-- Usage -->
<host-selector></host-selector>
<host-selector class="highlighted"></host-selector>
```

### :host() Function

```html
<host-function></host-function>

<script>
  class HostFunction extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Style host when it matches a selector */
          :host(.large) {
            font-size: 24px;
          }

          :host(.small) {
            font-size: 12px;
          }

          /* Style host based on attributes */
          :host([disabled]) {
            opacity: 0.5;
            pointer-events: none;
          }

          :host([theme="dark"]) {
            background-color: #333;
            color: white;
          }

          .content {
            padding: 10px;
          }
        </style>

        <div class="content">Host function styling</div>
      `;
    }
  }

  customElements.define('host-function', HostFunction);
</script>

<!-- Usage -->
<host-function class="large">Large text</host-function>
<host-function class="small">Small text</host-function>
<host-function disabled>Disabled</host-function>
<host-function theme="dark">Dark theme</host-function>
```

### :host-context() Selector

```html
<div class="theme-light">
  <host-context></host-context>
</div>

<div class="theme-dark">
  <host-context></host-context>
</div>

<script>
  class HostContext extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Style based on ancestor elements */
          :host-context(.theme-light) {
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #dee2e6;
          }

          :host-context(.theme-dark) {
            background-color: #343a40;
            color: #fff;
            border: 1px solid #495057;
          }

          :host-context(.theme-light) .content {
            color: #007bff;
          }

          :host-context(.theme-dark) .content {
            color: #ffc107;
          }
        </style>

        <div class="content">Content adapts to theme</div>
      `;
    }
  }

  customElements.define('host-context', HostContext);
</script>
```

---

## üé® Advanced Styling

### ::slotted() Pseudo-element

```html
<template id="slotted-template">
  <style>
    /* Style elements that are slotted into named slots */
    ::slotted(.highlight) {
      background-color: yellow;
      font-weight: bold;
    }

    ::slotted(h2) {
      color: blue;
      margin-top: 0;
    }

    ::slotted(p) {
      color: #666;
      line-height: 1.6;
    }

    /* Style all slotted content */
    ::slotted(*) {
      margin-bottom: 10px;
    }
  </style>

  <div class="card">
    <slot name="header">Default Header</slot>
    <slot name="content">Default Content</slot>
    <slot name="footer"></slot>
  </div>
</template>

<script>
  class SlottedExample extends HTMLElement {
    constructor() {
      super();

      const template = document.getElementById('slotted-template');
      const shadow = this.attachShadow({ mode: 'open' });
      shadow.appendChild(template.content.cloneNode(true));
    }
  }

  customElements.define('slotted-example', SlottedExample);
</script>

<!-- Usage -->
<slotted-example>
  <h2 slot="header">Styled Header</h2>
  <p slot="content">This paragraph will be styled.</p>
  <p slot="content" class="highlight">This paragraph is highlighted.</p>
  <small slot="footer">Footer content</small>
</slotted-example>
```

### CSS Custom Properties (CSS Variables)

```html
<css-variables></css-variables>

<script>
  class CSSVariables extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Define custom properties in shadow DOM */
          :host {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --border-radius: 4px;
            --padding: 10px;
          }

          .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: var(--padding);
            cursor: pointer;
          }

          .button:hover {
            background-color: var(--secondary-color);
          }

          .card {
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: var(--padding);
          }
        </style>

        <div class="card">
          <button class="button">Click me</button>
          <p>Custom properties in Shadow DOM</p>
        </div>
      `;
    }
  }

  customElements.define('css-variables', CSSVariables);
</script>
```

### CSS Custom Properties from Host

```html
<custom-properties></custom-properties>

<style>
  /* Define CSS variables on host */
  custom-properties {
    --theme-color: #28a745;
    --text-size: 18px;
  }
</style>

<script>
  class CustomProperties extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          /* Use CSS variables from host */
          .content {
            color: var(--theme-color, blue);
            font-size: var(--text-size, 16px);
            padding: 10px;
            border: 2px solid var(--theme-color, blue);
          }
        </style>

        <div class="content">
          Content styled with host CSS variables
        </div>
      `;
    }
  }

  customElements.define('custom-properties', CustomProperties);
</script>
```

---

## üîß Shadow DOM API

### Accessing Shadow DOM Elements

```html
<shadow-api></shadow-api>

<script>
  class ShadowAPI extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <div class="container">
          <button class="action-btn">Click me</button>
          <div class="output">No clicks yet</div>
        </div>
      `;

      // Store references to shadow DOM elements
      this.button = shadow.querySelector('.action-btn');
      this.output = shadow.querySelector('.output');
      this.clickCount = 0;

      // Bind event handler
      this.handleClick = this.handleClick.bind(this);
    }

    connectedCallback() {
      // Attach event listener
      this.button.addEventListener('click', this.handleClick);
    }

    disconnectedCallback() {
      // Clean up event listener
      this.button.removeEventListener('click', this.handleClick);
    }

    handleClick() {
      this.clickCount++;
      this.output.textContent = `Button clicked ${this.clickCount} times`;
    }

    // Public method to reset counter
    reset() {
      this.clickCount = 0;
      this.output.textContent = 'Counter reset';
    }
  }

  customElements.define('shadow-api', ShadowAPI);

  // Usage from outside
  const component = document.querySelector('shadow-api');
  // component.reset(); // Call public method
</script>
```

### Shadow DOM Events

```html
<event-demo></event-demo>

<script>
  class EventDemo extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <button class="shadow-btn">Shadow Button</button>
        <div class="log">Event log:</div>
      `;

      this.button = shadow.querySelector('.shadow-btn');
      this.log = shadow.querySelector('.log');
    }

    connectedCallback() {
      // Events from shadow DOM can bubble up
      this.button.addEventListener('click', event => {
        console.log('Shadow button clicked');
        this.logEvent('Shadow button clicked');

        // Custom event that bubbles up
        this.dispatchEvent(
          new CustomEvent('shadow-click', {
            detail: { timestamp: Date.now() },
            bubbles: true, // Allow event to bubble
            composed: true, // Allow event to cross shadow boundaries
          }),
        );
      });
    }

    logEvent(message) {
      const timestamp = new Date().toLocaleTimeString();
      this.log.innerHTML += `<br>${timestamp}: ${message}`;
    }
  }

  customElements.define('event-demo', EventDemo);

  // Listen for custom events from shadow DOM
  document
    .querySelector('event-demo')
    .addEventListener('shadow-click', event => {
      console.log('Custom event received:', event.detail);
    });
</script>
```

---

## üéØ Advanced Shadow DOM

### Multiple Shadow Roots

```html
<multi-shadow></multi-shadow>

<script>
  class MultiShadow extends HTMLElement {
    constructor() {
      super();

      // First shadow root
      const shadow1 = this.attachShadow({ mode: 'open' });
      shadow1.innerHTML = `
        <style>
          .layer1 { color: red; font-size: 20px; }
        </style>
        <div class="layer1">First shadow layer</div>
      `;

      // Second shadow root (replaces first)
      const shadow2 = this.attachShadow({ mode: 'open' });
      shadow2.innerHTML = `
        <style>
          .layer2 { color: blue; font-size: 24px; }
        </style>
        <div class="layer2">Second shadow layer</div>
      `;

      console.log(this.shadowRoot === shadow2); // true
    }
  }

  customElements.define('multi-shadow', MultiShadow);
</script>
```

### Nested Shadow DOM

```html
<nested-shadow></nested-shadow>

<script>
  class NestedShadow extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          .parent { border: 2px solid blue; padding: 10px; }
        </style>

        <div class="parent">
          Parent shadow content
          <child-shadow></child-shadow>
        </div>
      `;
    }
  }

  class ChildShadow extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          .child {
            border: 2px solid red;
            padding: 10px;
            margin: 10px;
            background-color: lightyellow;
          }
        </style>

        <div class="child">
          Child shadow content (nested)
        </div>
      `;
    }
  }

  customElements.define('nested-shadow', NestedShadow);
  customElements.define('child-shadow', ChildShadow);
</script>
```

### Shadow DOM and Forms

```html
<form-shadow></form-shadow>

<script>
  class FormShadow extends HTMLElement {
    constructor() {
      super();

      const shadow = this.attachShadow({ mode: 'open' });
      shadow.innerHTML = `
        <style>
          form { margin: 10px 0; }
          input { margin: 5px 0; padding: 5px; }
          button {
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
          }
        </style>

        <form id="shadow-form">
          <input type="text" name="username" placeholder="Username" required>
          <input type="email" name="email" placeholder="Email" required>
          <button type="submit">Submit</button>
        </form>

        <div id="result"></div>
      `;

      this.form = shadow.getElementById('shadow-form');
      this.result = shadow.getElementById('result');
    }

    connectedCallback() {
      this.form.addEventListener('submit', event => {
        event.preventDefault();

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData);

        this.result.innerHTML = `
          <strong>Form submitted:</strong><br>
          Username: ${data.username}<br>
          Email: ${data.email}
        `;
      });
    }
  }

  customElements.define('form-shadow', FormShadow);
</script>
```

---

## üîç Shadow DOM Inspection

### Browser Developer Tools

```javascript
// In browser console
const element = document.querySelector('my-component');

// Check if element has shadow root
console.log(element.shadowRoot); // ShadowRoot or null

// Inspect shadow DOM content
console.log(element.shadowRoot.innerHTML);

// Find elements in shadow DOM
const shadowElement = element.shadowRoot.querySelector('.my-class');
console.log(shadowElement);

// Get all shadow DOM styles
const styles = element.shadowRoot.querySelectorAll('style');
styles.forEach(style => console.log(style.textContent));
```

### Programmatic Inspection

```javascript
class InspectableComponent extends HTMLElement {
  constructor() {
    super();

    const shadow = this.attachShadow({ mode: 'open' });
    shadow.innerHTML = `
      <div class="inspectable">Inspectable content</div>
      <button class="action">Action button</button>
    `;

    // Make shadow root inspectable
    if (window.ShadowDOMPolyfill) {
      // For older browsers with polyfills
      this.shadowRoot = shadow;
    }
  }

  // Method to expose shadow DOM content
  getShadowContent() {
    return {
      html: this.shadowRoot.innerHTML,
      elements: Array.from(this.shadowRoot.querySelectorAll('*')),
      styles: Array.from(this.shadowRoot.querySelectorAll('style')),
    };
  }

  // Method to find elements in shadow DOM
  findInShadow(selector) {
    return this.shadowRoot.querySelector(selector);
  }
}

customElements.define('inspectable-component', InspectableComponent);

// Usage
const component = document.querySelector('inspectable-component');
const content = component.getShadowContent();
const button = component.findInShadow('.action');
```

---

## üéØ Best Practices

### ‚úÖ DO:

```javascript
// Always use Shadow DOM for component encapsulation
class MyComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    // Add content to shadow
  }
}

// Use :host for styling the component itself
:host {
  display: block;
  border: 1px solid #ccc;
}

// Use CSS custom properties for theming
:host {
  --primary-color: #007bff;
  --border-radius: 4px;
}

// Dispatch composed events to communicate with parent
this.dispatchEvent(new CustomEvent('value-changed', {
  detail: { value: this.value },
  bubbles: true,
  composed: true
}));

// Clean up event listeners in disconnectedCallback
disconnectedCallback() {
  this.button.removeEventListener('click', this.handleClick);
}
```

### ‚ùå DON'T:

```javascript
// Don't attach multiple shadow roots
// this.attachShadow({ mode: 'open' }); // Only once per element

// Don't use closed mode unless necessary
// Closed mode prevents legitimate access
const shadow = this.attachShadow({ mode: 'closed' }); // Avoid

// Don't query shadow DOM from outside
// element.shadowRoot.querySelector() // Won't work with closed mode

// Don't forget to handle composed events
// Events won't bubble out of shadow DOM without composed: true

// Don't style shadow DOM from outside
<style>my-component .shadow-class {/* This won't work */}</style>;
```

---

## üöÄ What's Next?

You've completed all HTML Advanced topics! Now explore **Accessibility** for
inclusive web development:

üëâ [Next: Accessibility ‚Üí](./accessibility.mdx)

Or return to the [HTML Overview ‚Üí](../index.mdx)

Master Shadow DOM for encapsulated component styling! üåë
